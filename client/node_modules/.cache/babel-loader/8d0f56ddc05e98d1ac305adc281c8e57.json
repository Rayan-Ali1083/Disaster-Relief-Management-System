{"ast":null,"code":"'use strict';\n\n// tar -r\nconst hlo = require('./high-level-opt.js');\nconst Pack = require('./pack.js');\nconst fs = require('fs');\nconst fsm = require('fs-minipass');\nconst t = require('./list.js');\nconst path = require('path');\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js');\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_);\n  if (!opt.file) {\n    throw new TypeError('file is required');\n  }\n  if (opt.gzip) {\n    throw new TypeError('cannot append to compressed archives');\n  }\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified');\n  }\n  files = Array.from(files);\n  return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);\n};\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt);\n  let threw = true;\n  let fd;\n  let position;\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+');\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+');\n      } else {\n        throw er;\n      }\n    }\n    const st = fs.fstatSync(fd);\n    const headBuf = Buffer.alloc(512);\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives');\n        }\n        if (!bytes) {\n          break POSITION;\n        }\n      }\n      const h = new Header(headBuf);\n      if (!h.cksumValid) {\n        break;\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > st.size) {\n        break;\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize;\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n    }\n    threw = false;\n    streamSync(opt, p, position, fd, files);\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd);\n      } catch (er) {}\n    }\n  }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position\n  });\n  p.pipe(stream);\n  addFilesSync(p, files);\n};\nconst replace = (opt, files, cb) => {\n  files = Array.from(files);\n  const p = new Pack(opt);\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er));\n      } else {\n        cb_(null, pos);\n      }\n    };\n    let position = 0;\n    if (size === 0) {\n      return cb(null, 0);\n    }\n    let bufPos = 0;\n    const headBuf = Buffer.alloc(512);\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er);\n      }\n      bufPos += bytes;\n      if (bufPos < 512 && bytes) {\n        return fs.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n      }\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'));\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position);\n      }\n      const h = new Header(headBuf);\n      if (!h.cksumValid) {\n        return cb(null, position);\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512);\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position);\n      }\n      position += entryBlockSize + 512;\n      if (position >= size) {\n        return cb(null, position);\n      }\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime);\n      }\n      bufPos = 0;\n      fs.read(fd, headBuf, 0, 512, position, onread);\n    };\n    fs.read(fd, headBuf, 0, 512, position, onread);\n  };\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject);\n    let flag = 'r+';\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+';\n        return fs.open(opt.file, flag, onopen);\n      }\n      if (er) {\n        return reject(er);\n      }\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er));\n        }\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er);\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position\n          });\n          p.pipe(stream);\n          stream.on('error', reject);\n          stream.on('close', resolve);\n          addFilesAsync(p, files);\n        });\n      });\n    };\n    fs.open(opt.file, flag, onopen);\n  });\n  return cb ? promise.then(cb, cb) : promise;\n};\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry)\n      });\n    } else {\n      p.add(file);\n    }\n  });\n  p.end();\n};\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift();\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry)\n      }).then(_ => addFilesAsync(p, files));\n    } else {\n      p.add(file);\n    }\n  }\n  p.end();\n};","map":{"version":3,"names":["hlo","require","Pack","fs","fsm","t","path","Header","module","exports","opt_","files","cb","opt","file","TypeError","gzip","Array","isArray","length","from","sync","replaceSync","replace","p","Sync","threw","fd","position","openSync","er","code","st","fstatSync","headBuf","Buffer","alloc","POSITION","size","bufPos","bytes","readSync","Error","h","cksumValid","entryBlockSize","Math","ceil","mtimeCache","set","mtime","streamSync","closeSync","stream","WriteStreamSync","start","pipe","addFilesSync","getPos","cb_","pos","close","_","onread","read","promise","Promise","resolve","reject","on","flag","onopen","open","fstat","WriteStream","addFilesAsync","then","forEach","charAt","cwd","slice","noResume","onentry","entry","add","end","shift"],"sources":["C:/Users/Dell 9010/Desktop/Disaster Relief Management System/client/node_modules/tar/lib/replace.js"],"sourcesContent":["'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}