{"ast":null,"code":"'use strict';\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nclass PackJob {\n  constructor(path, absolute) {\n    this.path = path || './';\n    this.absolute = absolute;\n    this.entry = null;\n    this.stat = null;\n    this.readdir = null;\n    this.pending = false;\n    this.ignore = false;\n    this.piped = false;\n  }\n}\nconst MiniPass = require('minipass');\nconst zlib = require('minizlib');\nconst ReadEntry = require('./read-entry.js');\nconst WriteEntry = require('./write-entry.js');\nconst WriteEntrySync = WriteEntry.Sync;\nconst WriteEntryTar = WriteEntry.Tar;\nconst Yallist = require('yallist');\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\nconst fs = require('fs');\nconst path = require('path');\nconst warner = require('./warn-mixin.js');\nconst normPath = require('./normalize-windows-path.js');\nconst Pack = warner(class Pack extends MiniPass {\n  constructor(opt) {\n    super(opt);\n    opt = opt || Object.create(null);\n    this.opt = opt;\n    this.file = opt.file || '';\n    this.cwd = opt.cwd || process.cwd();\n    this.maxReadSize = opt.maxReadSize;\n    this.preservePaths = !!opt.preservePaths;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.prefix = normPath(opt.prefix || '');\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.readdirCache = opt.readdirCache || new Map();\n    this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn);\n    }\n    this.portable = !!opt.portable;\n    this.zip = null;\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') {\n        opt.gzip = {};\n      }\n      if (this.portable) {\n        opt.gzip.portable = true;\n      }\n      this.zip = new zlib.Gzip(opt.gzip);\n      this.zip.on('data', chunk => super.write(chunk));\n      this.zip.on('end', _ => super.end());\n      this.zip.on('drain', _ => this[ONDRAIN]());\n      this.on('resume', _ => this.zip.resume());\n    } else {\n      this.on('drain', this[ONDRAIN]);\n    }\n    this.noDirRecurse = !!opt.noDirRecurse;\n    this.follow = !!opt.follow;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true;\n    this[QUEUE] = new Yallist();\n    this[JOBS] = 0;\n    this.jobs = +opt.jobs || 4;\n    this[PROCESSING] = false;\n    this[ENDED] = false;\n  }\n  [WRITE](chunk) {\n    return super.write(chunk);\n  }\n  add(path) {\n    this.write(path);\n    return this;\n  }\n  end(path) {\n    if (path) {\n      this.write(path);\n    }\n    this[ENDED] = true;\n    this[PROCESS]();\n    return this;\n  }\n  write(path) {\n    if (this[ENDED]) {\n      throw new Error('write after end');\n    }\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path);\n    } else {\n      this[ADDFSENTRY](path);\n    }\n    return this.flowing;\n  }\n  [ADDTARENTRY](p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path));\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume();\n    } else {\n      const job = new PackJob(p.path, absolute, false);\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n      job.entry.on('end', _ => this[JOBDONE](job));\n      this[JOBS] += 1;\n      this[QUEUE].push(job);\n    }\n    this[PROCESS]();\n  }\n  [ADDFSENTRY](p) {\n    const absolute = normPath(path.resolve(this.cwd, p));\n    this[QUEUE].push(new PackJob(p, absolute));\n    this[PROCESS]();\n  }\n  [STAT](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    const stat = this.follow ? 'stat' : 'lstat';\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n      if (er) {\n        this.emit('error', er);\n      } else {\n        this[ONSTAT](job, stat);\n      }\n    });\n  }\n  [ONSTAT](job, stat) {\n    this.statCache.set(job.absolute, stat);\n    job.stat = stat;\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true;\n    }\n    this[PROCESS]();\n  }\n  [READDIR](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n      if (er) {\n        return this.emit('error', er);\n      }\n      this[ONREADDIR](job, entries);\n    });\n  }\n  [ONREADDIR](job, entries) {\n    this.readdirCache.set(job.absolute, entries);\n    job.readdir = entries;\n    this[PROCESS]();\n  }\n  [PROCESS]() {\n    if (this[PROCESSING]) {\n      return;\n    }\n    this[PROCESSING] = true;\n    for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n      this[PROCESSJOB](w.value);\n      if (w.value.ignore) {\n        const p = w.next;\n        this[QUEUE].removeNode(w);\n        w.next = p;\n      }\n    }\n    this[PROCESSING] = false;\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF);\n      } else {\n        super.write(EOF);\n        super.end();\n      }\n    }\n  }\n  get [CURRENT]() {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n  }\n  [JOBDONE](job) {\n    this[QUEUE].shift();\n    this[JOBS] -= 1;\n    this[PROCESS]();\n  }\n  [PROCESSJOB](job) {\n    if (job.pending) {\n      return;\n    }\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job);\n      }\n      return;\n    }\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute));\n      } else {\n        this[STAT](job);\n      }\n    }\n    if (!job.stat) {\n      return;\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return;\n    }\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute));\n      } else {\n        this[READDIR](job);\n      }\n      if (!job.readdir) {\n        return;\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job);\n    if (!job.entry) {\n      job.ignore = true;\n      return;\n    }\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job);\n    }\n  }\n  [ENTRYOPT](job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix\n    };\n  }\n  [ENTRY](job) {\n    this[JOBS] += 1;\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', () => this[JOBDONE](job)).on('error', er => this.emit('error', er));\n    } catch (er) {\n      this.emit('error', er);\n    }\n  }\n  [ONDRAIN]() {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume();\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE](job) {\n    job.piped = true;\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path;\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n        this[ADDFSENTRY](base + entry);\n      });\n    }\n    const source = job.entry;\n    const zip = this.zip;\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause();\n        }\n      });\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause();\n        }\n      });\n    }\n  }\n  pause() {\n    if (this.zip) {\n      this.zip.pause();\n    }\n    return super.pause();\n  }\n});\nclass PackSync extends Pack {\n  constructor(opt) {\n    super(opt);\n    this[WRITEENTRYCLASS] = WriteEntrySync;\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause() {}\n  resume() {}\n  [STAT](job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync';\n    this[ONSTAT](job, fs[stat](job.absolute));\n  }\n  [READDIR](job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute));\n  }\n\n  // gotta get it all in this tick\n  [PIPE](job) {\n    const source = job.entry;\n    const zip = this.zip;\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path;\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n        this[ADDFSENTRY](base + entry);\n      });\n    }\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk);\n      });\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk);\n      });\n    }\n  }\n}\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":{"version":3,"names":["PackJob","constructor","path","absolute","entry","stat","readdir","pending","ignore","piped","MiniPass","require","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","Buffer","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","normPath","Pack","opt","Object","create","file","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","linkCache","Map","statCache","readdirCache","onwarn","on","portable","zip","gzip","Gzip","chunk","write","_","end","resume","noDirRecurse","follow","noMtime","mtime","filter","jobs","add","Error","flowing","p","resolve","job","push","er","emit","set","entries","w","head","next","value","removeNode","length","shift","has","get","isDirectory","code","msg","data","warn","forEach","base","replace","source","pause","PackSync","readdirSync","module","exports"],"sources":["C:/Users/Dell 9010/Desktop/Disaster Relief Management System/client/node_modules/tar/lib/pack.js"],"sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') {\n        opt.gzip = {}\n      }\n      if (this.portable) {\n        opt.gzip.portable = true\n      }\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}